---
layout:     post
title:      Умовні оператори в JS
date:       2016-02-07
summary:    Реалізація алгоритмів з розгалуженням
categories: lits
---

Вивчаючи основи програмування потрібно освоїти не лише одну з мов програмування високого рівня, а й навчитися складати та аналізувати алгоритми розв’язку різних задач, і таким чином, виробити алгоритмічне мислення.

Поняття алгоритму є одним з фундаментальних понять в комп’ютерних науках. Воно виникло задовго до появи перших комп’ютерів і стало одним з основних у математиці. Вважається, що саме слово “алгоритм” походить від імені видатного математика середньовіччя Мухаммеда бен-Муси аль-Хорезмі. Він розробив алгоритм (правила) виконання арифметичих дій над десятковими числами, яким ми користуємось до сих пір. Тепер слово “алгоритм” використовується не тільки в математиці, так говорять про алгоритм гри у шахи, алгоритм керування різними процесами тощо.

Для розуміння поняття “алгоритм” та його ролі в програмуванні не обов’язково застосовувати строго математичний формалізм, достатньо дати тлумачення цього поняття на “інтуїтивному” рівні. Тут, в першу чергу, слід відзначити важливе значення поняття “виконавець алгоритму”. Алгоритм завжди повинен бути сформульованим у розрахунку на конкретного виконавця, тобто він має бути керівництвом до дій для виконавця. Саме тому, значення слова “алгоритм” є схожим за змістом до значення слів “вказівка”, “інструкція”. Можна стверджувати, що __алгоритм – це зрозумілі й точні вказівки виконавцю (комп’ютеру) здійснити певну послідовність дій (обчислювальних операцій) для розв’язання поставленої задачі.__

Будь-який алгоритм стає алгоритмом лише тоді, коли він набере якої-небудь форми. В програмуванні склалися повністю визначені традиції в поданні алгоритмів, а саме розрізняють такі форми запису алгоритмів:

- словесний запис алгоритму (розмовна мова);
- псевдокод (структурно-стилізована мова);
- блок-схема (мова графічних символів);
- комп’ютерна програма (мова програмування високого рівня)

 **Словесний запис алгоритму** орієнтований, взагалі кажучи, на людину як виконавця. В програмуванні він використовується лише на першому етапі розробки програми, коли потрібно подати алгоритм в цілому, усвідомити послідовність виконання дій та логічні зв’язки між ними, проглянути можливі варіанти. Словесна форма допускає найбільшу свободу дій в способах опису як послідовності дій, так і рівня їх деталізації, і таким чином вона є найменш формалізованою і строгою.

Наступним кроком у напрямку підвищення рівня формалізації опису алгоритму є використання так званого псевдокоду. **Псевдокод** – це система позначень і правил, призначена для одноманітного запису алгоритмів. У псевдокоді відсутні строгі синтаксичні правила для запису команд, тому програма на псевдокоді не може виконуватися комп’ютером. Його призначення – допомогти розробнику “осмислити” програму перед тим як спробувати її написати мовою програмування такою як JavaScript. А завдяки наявності конструкцій, які притаманні мовам програмування, значно полегшується перехід від детально підготовленої програми на псевдокоді до програми написаної мовою JavaScript.

На одному рівні формалізації опису алгоритму поряд з псевдокодом знаходиться графічна форма опису у вигляді **блок-схеми**. Основною перевагою блок-схем над псевдокодом є більша наочність подання алгоритму. Але для великих алгоритмів ця перевага втрачається. В блок-схемах для позначення алгоритму використовуються спеціальні символи у вигляді найпрос­тіших геометричних фігур, які називаються блоками. Блоки з’єднуються за допомогою стрілок, які називаються лініями зв’язку і які вказують на черговість виконання. Самі команди поміщаються усередину блоків і можуть набувати, взагалі кажучи, довільної форми, наприклад, задаватися словами (хоча в такому випадку формалізація опису зменшуються). Блок-схеми можуть використовуватися як для опису повного алгоритму, так і для опису деякого фрагменту алгоритма.

З певних комбінацій блоку виконання дій та логічного блоку створюються керуючі структури або базові конструкції алгоритмів. В теорії алгоритмів доведено, що будь-який алгоритм може бути побудований з використанням всього лише трьох базових конструкцій, а саме з **конструкцій слідування, розгалуження та повторення**. Це перетворює процес побудови алгоритму в його “збірку” з набору базових конструкцій. Блок-схеми керуючих структур можна розглядати як блок-схеми фрагментів алгоритму, тобто вони починатимуться з блоку злиття, який буде відігравати роль точки входу в структуру і закінчуватися також цим блоком, який буде точкою виходу з структури. Таке трактування керуючих структур з одним входом і одним виходом значно полегшує процес побудови алгоритму шляхом збирання з базових конструкцій – керуючі структури зв’язуються послідовно шляхом з’єднання точки виходу однієї з них з точкою входу іншої. Іншим способом збирання цілого алгоритму з базових конструкцій є вкладення однієї керуючої структури в іншу. Його ми розглянемо детально пізніше.

Під час запису алгоритму у словесній формі, у вигляді блок-схеми чи на псевдокоді допускається певна довільність в записі команд. На практиці як виконавець алгоритмів використовують комп’ютер, тому алгоритм має бути записаний мовою “зрозумілою” комп’ютером. Тут на перший план виступає необхідність точного запису команд, яка не залишає місця для довільного тлумачення їх виконавцем. Тому мова для запису алгоритму має бути строго формалізована – вона називається мовою програмування, а форма алгоритму цією мовою – комп’ютерною програмою або просто програмою.

Отже, будь-який алгоритм може бути побудований з використанням всього лише трьох базових конструкцій, а саме конструкцій слідування, розгалуження та повторення. Структура слідування вбудована в мові JavaScript. Це означає, що оператори програми виконуються один за одним в тій послідовності, в якій вони записані у тексті програми, поки не буде вказано інший порядок виконання.

## Умовні оператори JS
Управління послідовністю дій, під час виконання сценарію, виконувався за допомогою операторів. JavaScript містить стандартний набір операторів, успадкований від мов C++ та Java:

- умовний оператор <a href="http://www.w3schools.com/js/js_if_else.asp">if/else</a>;
- оператор вибору <a href="http://www.w3schools.com/js/js_switch.asp">switch</a>;
- оператори циклу  <a href="http://www.w3schools.com/js/js_loop_while.asp">while</a>, do…while, break и continue, for;
- оператор ітерації for…in;
- оператор вказання обекту with;

Будь який вираз JavaScript також є оператором.

### Оператор if

Умовний оператор if…else дозволяє перевірити певну умову та, в залежності від результату, виконати ту чі іншу послідовність операторів. Він має дві форми представлення:

> if (умова) оператор1<br>

> if (умова) оператор1 <br>
else оператор2

Спочатку обчислюється <умова>, яка синтаксично задається у вигляді виразу, значення якого може бути переведене до логічного типу, оператор1 и оператор2 — будьякі групи операторів JavaScript;
Якщо ці *групи* містять більше одного оператора вони повинні бути включені в фігурні дужки {}.

Тут умова — це вираз значення якого може бути переведене до логічного типу true або false

  <iframe width="100%" height="300" src="//jsfiddle.net/mykolat/mn3xa0L9/embedded/js/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

Таким чином, виконання оператора if полягає в наступному: якщо <умова> є істинною, то виконується <оператор>, якщо <умова> є хибною, то оператор заданий після умови виконуватися не буде, а програма продовжить своє виконання з наступного після if оператора.

У ролі <оператор1> та <оператор2> може бути будь-який допустимий оператор, в тому числі й сам оператор умови. У такому випадку отримуємо вкладені структури if/else, які дозволяють реалізувати розгалуження обчислювального процесу більше ніж у двох напрямках. Тут слід пам’ятати, що кожне службове слово else відноситься до першого перед ним слова if. Так, наприклад, при заданих початкових значеннях x=1; y=-1, після виконання оператора
<code>if (x>0) if (y>0) z=1; else z=2;</code>
змінна z буде мати значення 2. Якщо ми хочемо, щоб гілка else z=2; відносилася не до умови if (y>0), а до if (x>0), то треба цей оператор записати так:
<code>if (x>0) {if (y>0) z=1;} else z=2;</code>

### Оператори порівняння

Оператор порівняння порівнює його операнди і повертає логічне значення, засноване на тому, чи є порівняння true або false. Операнди можуть бути чисельними або рядковими значеннями. Коли використовується на строкових значення, то порівняння грунтується на стандартному лексикографічному порядку.

Оператори:

- Дорівнює "==": повертає true, якщо операнди рівні.
- Не дорівнює "!=": повертає true, якщо операнди не рівні.
- Більше ніж ">": повертає true, якщо лівий операнд більше ніж правий операнд.
- Більше або рівне ">=": повертає true, якщо лівий операнд більший або дорівнює правому операндів.
- Менше ніж "<": повертає true, якщо лівий операнд - менше ніж правий перанд.
- Менше або рівне "<=": повертає true, якщо лівий операнд - менше або дорівнює правому операнду.

<iframe width="100%" height="300" src="//jsfiddle.net/mykolat/vxwbbg7j/embedded/js/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

>X == Y: a = 4, b = 4   a == b => true<br>
>X != Y: a = 4, b = 5   a != b => true<br>
>X > Y: a = 7, b = 6   a > b  => true<br>

>X >= Y: a = 3, b = 5   a >= b => false<br>
>X < Y: a = 8, b = 1   a < b  => false<br>
>X <= Y: a = 9, b = 0   a <= b => false<br>

### Логічні оператори

Логічні оператори беруть логічні (Булеві) значення як операнди. Вони повертають логічне значення.
Логічні значення true (істина) і false (брехня).

#### Оператор AND (&&)

<code>Expr1 && Expr2</code>

Логічний AND повертає оператор true, якщо обидва логічних вирази та Expr1 і Expr2 мають однакове значення. Інакше, повертається false.

#### Оператор OR (||)

<code>Expr1 || Expr2</code>

Логічний OR' повертає оператор true, якщо хоча б одне з логічних виразів або Expr1 або Expr2 має значення true. Якщо і Expr1 і Expr2 мають значення false, то повертається значення false.

#### Оператор NOT (!)
<code>!Expr</code>

Логічний оператор NOT' - унарний оператор, який заперечує вислів операнда Expr. Тобто якщо Expr мав значення true, то повертає false, і якщо Expr мав значення false, то повертає true.

####Обчислення

Так як логічні вирази обчислюються зліва направо, то вони перевірені для можливого обчислення "короткого ланцюга", використовуючи таке правило:

>"false && Будь-який" - короткий ланцюг, оцінюється як false.<br>
>"true || Будь-який" - короткий ланцюг, оцінюється як true.

Логічне правило гарантує, що ці обчислення будуть завжди правильними.

## Контрольні запитання
- Що таке алгорим?
- Що буде якщо порівняти наступні значення:

<code>
100=="100"<br>
"abc"=="abs"<br>
"A"<"a"<br>
</code>
